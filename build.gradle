plugins {
    id "java"
    id "edu.wpi.first.GradleRIO" version "2026.2.1"
}

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

def MAC_MAIN_CLASS = "frc.robot.mac.Main"

sourceSets {
    macbot {
        java {
            srcDirs = ['src/main/java']
            include 'frc/robot/mac/**/*.java'

        }
    }
}

eclipse {
    classpath {
        sourceSets -= sourceSets.macbot
    }
}

// Force mac code to compile with main project's dependencies
afterEvaluate {
    // Make macbotImplementation inherit the project's implementation deps
    if (configurations.findByName('macbotImplementation')) {
        configurations.macbotImplementation.extendsFrom(configurations.implementation)
    }

    // Add main output + runtime deps to macbot compile/runtime classpath so mac files compile
    sourceSets.macbot.compileClasspath += sourceSets.main.output + configurations.runtimeClasspath
    sourceSets.macbot.runtimeClasspath += sourceSets.main.output + configurations.runtimeClasspath
}

// Define a new Jar task for the files in frc/robot/mac
task macJar(type: Jar) {
    group = 'application'
    description = 'Assembles a JAR containing the files in frc/robot/mac.'

    // Include files from the specified directory
    from sourceSets.macbot.output

    // Includes all dependencies from parent project
    from { configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) } }

    // Handle duplicate files
    duplicatesStrategy = DuplicatesStrategy.INCLUDE

    // Add a manifest if needed
    manifest {
        attributes(
            'Main-Class': MAC_MAIN_CLASS // Replace with the actual main class for this JAR
        )
    }

    // Set the output JAR file name
    archiveBaseName.set('MacRobot')
    destinationDirectory = file("src/main/deploy")
}

// Task to run the Mac standalone program locally
task runMac(type: JavaExec) {
    group = 'application'
    description = 'Runs the Mac Mini vision processor standalone program'

    classpath = files('/Users/lightning/MacRobot.jar')
    mainClass = MAC_MAIN_CLASS

    // Depend on native library extraction
    dependsOn 'extractReleaseNative'

    // Point to extracted native libraries
    systemProperty 'java.library.path', "${buildDir}/jni/release"

    // Configure this task with WPILib simulation libraries after project evaluation
    project.afterEvaluate {
        // Add native and simulation libraries to classpath
        classpath += configurations.nativeRelease
        classpath += configurations.simulationRelease
    }
}

def ROBOT_MAIN_CLASS = "frc.robot.Main"

// Define my targets (RoboRIO) and artifacts (deployable files)
// This is added by GradleRIO's backing project DeployUtils.
deploy {
    targets {
        roborio(getTargetTypeClass('RoboRIO')) {
            // Team number is loaded either from the .wpilib/wpilib_preferences.json
            // or from command line. If not found an exception will be thrown.
            // You can use getTeamOrDefault(team) instead of getTeamNumber if you
            // want to store a team number in this file.
            team = project.frc.getTeamNumber()
            debug = project.frc.getDebugOrDefault(false)

            artifacts {
                // First part is artifact name, 2nd is artifact type
                // getTargetTypeClass is a shortcut to get the class type using a string

                frcJava(getArtifactTypeClass('FRCJavaArtifact')) {
                }

                // Static files artifact
                frcStaticFileDeploy(getArtifactTypeClass('FileTreeArtifact')) {
                    files = project.fileTree('src/main/deploy')
                    directory = '/home/lvuser/deploy'
                    deleteOldFiles = true // Change to true to delete files on roboRIO that no
                                           // longer exist in deploy directory of this project
                }

                frcJava(getArtifactTypeClass('FRCJavaArtifact')) {
                    postdeploy << { ctx ->
                        ctx.execute('scp /home/lvuser/deploy/MacRobot.jar lightning@10.8.62.11:')
                    }
                    postdeploy << { ctx ->
                        ctx.execute("ssh lightning@10.8.62.11 'echo \"[\$(TZ=America/New_York date)] Deployed MacRobotCode Jar\" >> ./deploylog.txt'")
                    }
                    
                }


                frcJava(getArtifactTypeClass('FRCJavaArtifact')) {
                    postdeploy << { ctx -> 
                        ctx.execute('/etc/init.d/update-mac')
                    }
                }
            }
        }
    }
}

def deployArtifact = deploy.targets.roborio.artifacts.frcJava

// Set to true to use debug for all targets including JNI, which will drastically impact
// performance.
wpi.java.debugJni = false

// Set this to true to enable desktop support.
def includeDesktopSupport = true

// Defining my dependencies. In this case, WPILib (+ friends), and vendor libraries.
// Also defines JUnit 5.
dependencies {
    annotationProcessor wpi.java.deps.wpilibAnnotations()
    implementation wpi.java.deps.wpilib()
    implementation wpi.java.vendor.java()

    roborioDebug wpi.java.deps.wpilibJniDebug(wpi.platforms.roborio)
    roborioDebug wpi.java.vendor.jniDebug(wpi.platforms.roborio)

    roborioRelease wpi.java.deps.wpilibJniRelease(wpi.platforms.roborio)
    roborioRelease wpi.java.vendor.jniRelease(wpi.platforms.roborio)

    nativeDebug wpi.java.deps.wpilibJniDebug(wpi.platforms.desktop)
    nativeDebug wpi.java.vendor.jniDebug(wpi.platforms.desktop)
    simulationDebug wpi.sim.enableDebug()

    nativeRelease wpi.java.deps.wpilibJniRelease(wpi.platforms.desktop)
    nativeRelease wpi.java.vendor.jniRelease(wpi.platforms.desktop)
    simulationRelease wpi.sim.enableRelease()

    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.1'
    testImplementation 'org.mockito:mockito-core:5.8.0'
    testImplementation 'org.mockito:mockito-junit-jupiter:5.8.0'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

test {
    useJUnitPlatform()
    systemProperty 'junit.jupiter.extensions.autodetection.enabled', 'true'
}

// Simulation configuration (e.g. environment variables).
wpi.sim.addGui().defaultEnabled = true
wpi.sim.addDriverstation()

// Setting up my Jar File. In this case, adding all libraries into the main jar ('fat jar')
// in order to make them all available at runtime. Also adding the manifest so WPILib
// knows where to look for our Robot Class.
jar {
    from { configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) } }
    from('src') { into 'backup/src' }
    from('vendordeps') { into 'backup/vendordeps' }
    from('build.gradle') { into 'backup' }
    manifest edu.wpi.first.gradlerio.GradleRIOPlugin.javaManifest(ROBOT_MAIN_CLASS)
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
}

// Configure jar and deploy tasks
deployArtifact.jarTask = jar
wpi.java.configureExecutableTasks(jar)
wpi.java.configureTestTasks(test)

// Configure string concat to always inline compile
tasks.withType(JavaCompile) {
    options.compilerArgs.add '-XDstringConcat=inline'
}
